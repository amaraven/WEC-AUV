% Ama Hartman

function [eStorageBatteryLvl, wecBatteryLvl, auvBatteryLvl, auvSchedule] = runPowerModel(simTime, wec, auvFleet, energyStorage, incorpStagger)
% simulateOperation steps through each timestep for the given simulation, 
% calculates battery levels of the WEC and all AUVs in its assigned fleet,
% and generates an operational state schedule for the AUV(s). 
%
% Inputs: 
% All generated by powerModel from user-inputs
% - simTime: [h] Time series for simulation 
% - wec: WEC object
% - auvFleet: (1xm) array of m AUV objects
% - energyStorage: EnergyStorage object
% - incorpStagger: Flag to (1) stagger AUV deployments, or (0) not
%
% Outputs: 
% - wecBatteryLvl: [Wh] (nx1) time series of WEC battery level
% - auvBatteryLvl: [Wh] (nxm) time series of AUV battery level(s) with m
%   corresponding to each auv in auvFleet
% - auvSchedule: time series of AUV operational state schedule with 1)
%   Executing AUV mission, 2) Recharging, 3) Docked and fully charged
% -------------------------------------------------------------------------


%% Pre-Timestep Calculations
dt = simTime(2) - simTime(1); 

auvBatteryLvl = zeros(length(simTime), length(auvFleet)); 
wecBatteryLvl = zeros(length(simTime)+1, 1); 
wecBatteryLvl(1) = wec.maxBattery;  % Initialize WEC battery at 100%
eStorageBatteryLvl = zeros(length(simTime)+1, 1);
eStorageBatteryLvl(1) = energyStorage.maxBattery * 0.85;  % Initialize central storage at 85%; 
auvSchedule = zeros(length(simTime), length(auvFleet)); 


%% Run timestep calculations
for i = 1:length(simTime)  

    %% WEC Battery & Power Gen Overflow
    % Calculate WEC battery level for next iteration & amount of power
    % generated for central battery storage

    wecBatteryLvl(i+1) = min(wecBatteryLvl(i) + (-wec.hotelLoad/wec.n_battery + wec.powerGenMeans(i)*wec.n_battery)*dt, wec.maxBattery);
    wec.battery = wecBatteryLvl(i);

    pGenToWEC = ((wec.maxBattery - wecBatteryLvl(i)) / (dt * wec.n_battery)) + (wec.hotelLoad/(wec.n_battery^2));

    % Calculate power overflow (to central storage)
    if pGenToWEC < wec.powerGenMeans(i)  
        extraPower = wec.powerGenMeans(i) - pGenToWEC;
   
    else  % All power generated goes to WEC
        extraPower = 0;  

    end

    if wecBatteryLvl(i+1) < wec.lowBatteryLvl
        warning('Low WEC battery. Need to implement WEC energy draw from central storage.')
    end

    %%
    auvOpStates = [auvFleet.opState];
    auvOpStates = auvOpStates(1:2:end);  % save only current operational state

    
    %% Central storage battery
    % Calculate energy storage battery level for next iteration using avg
    % power and opState(s) at current simTime
    
    % If >= 100% charged, dumps extra power and keeps battery at max
    eStorageBatteryLvl(i+1) = min(eStorageBatteryLvl(i) + (extraPower*energyStorage.n_wecPwrTrnsfr*energyStorage.n_battery + - energyStorage.hotelLoad/energyStorage.n_battery/energyStorage.n_powerTransfer - sum([auvFleet.wecBatteryDraw])/energyStorage.n_battery )*dt, energyStorage.maxBattery);  % [prev.battery + (draws & gains)*dt]
    eStorageLowBatteryFlag = 0;
    
    % If central battery is low, stop charging AUVs but still supply hotel loads
    if eStorageBatteryLvl(i+1) < energyStorage.lowBatteryLvl
        eStorageLowBatteryFlag = 1;
        eStorageBatteryLvl(i+1) =  min(eStorageBatteryLvl(i) + (extraPower*energyStorage.n_wecPwrTrnsfr*energyStorage.n_battery + - energyStorage.hotelLoad/energyStorage.n_battery/energyStorage.n_powerTransfer - sum( (auvOpStates == 3 | auvOpStates == 2) .* [auvFleet.hotelLoad] ./ [auvFleet.n_powerTransfer] ./ [auvFleet.n_battery]) /energyStorage.n_battery )*dt, energyStorage.maxBattery);  % [prev.battery + (draws & gains)*dt]
    end

    % Save current battery level in energy storage object (for battery estimation calcs)
    energyStorage.battery = eStorageBatteryLvl(i);  

    
    %% AUV Battery
    % Calculate and save AUV battery level(s)
    arrayfun(@(auv) auv.calcBatteryLvl(simTime(i)), auvFleet); 
    intBatteries = [auvFleet.battery];
    auvBatteryLvl(i,:) = intBatteries(2,:);
    

    %% AUV Operational State
    % Evaluate opState of AUV(s) & change as applicable

    % If central storage goes into battery-save mode, stop charging AUV(s)
    if eStorageLowBatteryFlag == 1
        indxCharging = auvOpStates == 2; 
        arrayfun(@(auv) auv.changeOpState(3, simTime(i)), auvFleet(indxCharging));

    else  % start charging auv's docked and still below max battery
        indxNeedCharge = logical( (auvOpStates == 3) .* (auvBatteryLvl(i,:) < [auvFleet.maxBattery]) );  
        arrayfun(@(auv) auv.changeOpState(2, simTime(i)), auvFleet(indxNeedCharge)); 

    end

    % Deployed AUV completes mission & returns
    onMissionLogic = (auvOpStates == 1);
    indxMissionComplete = logical( onMissionLogic .* ([auvFleet.opTimeComplete] <= simTime(i)) );
    arrayfun(@(auv) auv.changeOpState(2, simTime(i)), auvFleet(indxMissionComplete));

    % Charging AUV finishes charging: 
    indxChargingComplete = logical( (auvOpStates == 2) .* ([auvFleet.opTimeComplete] <= simTime(i)) ); 
    arrayfun(@(auv) auv.changeOpState(3, simTime(i)), auvFleet(indxChargingComplete)); 
    
    if incorpStagger == 1
        staggerHours = (auvFleet(1).missionSpecs(2)+auvFleet(1).chargeTime) /length(auvFleet);  % Proportional stagger yileds even breaks in deployment 
        if i == 1 
            simTimeLastDeployment = -staggerHours; 
        end 
        
    else
        simTimeLastDeployment = 0;
        staggerHours = 0;

    end

    % For docked AUV to leave: 
    % - AUV must have enough battery for the mission
    % - Central battery must have enough power to fully recharge AUV when it returns
    tempMissionBattUsed = arrayfun(@(auv) auv.missionSpecs(auv.mission, 3), auvFleet);
    auvReadyToDeploy = (auvOpStates ~= 1) .* (auvBatteryLvl(i,:) >= ([auvFleet.rechargeThreshold] + tempMissionBattUsed .* [auvFleet.maxBattery]) ); % cellfun(@(auv) (auv.rechargeThreshold + auv.missionSpecs(auv.mission, 3)) * auv.maxBattery, auvFleet) );  
    if any(auvReadyToDeploy ~= 0) && (simTime(i) > simTimeLastDeployment+staggerHours)
    % if any(auvReadyToDeploy ~= 0) 
        nonzroindx = find(auvReadyToDeploy); 
        auvToDeploy = nonzroindx(1);  % Deploy first AUV available

        [eStorageFutureBattery, eStorageNoBatteryFlag] = energyStorage.estBattery(auvFleet, simTime(i), dt, auvToDeploy, wec);
            
        % If estimated battery is above 0, and the central battery is not expected to drop below 0, send auv on mission
        if (eStorageFutureBattery > 0) && (eStorageNoBatteryFlag == 0) 
            arrayfun(@(auv) auv.changeOpState(1,simTime(i)), auvFleet(auvToDeploy));
            simTimeLastDeployment = simTime(i);
            
        end
    end

    % Save timestep operational states
    auvSchedule(i, :) = arrayfun(@(auv) auv.opState(1), auvFleet);

end  % timesteps


% Save battery levels for simulation domain
wecBatteryLvl = wecBatteryLvl(1:end-1); 
eStorageBatteryLvl = eStorageBatteryLvl(1:end-1); 

end